= Лабораторная работа 8
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица


include::titulnik8.adoc[]

== Основные особенности АЦП

Аналого-цифровой преобразователь (АЦП) в микроконтроллерах STM32F4 (включая STM32F411) представляет собой периферийный блок, оцифровывающий входной аналоговый сигнал в цифровое значение. Микроконтроллеры данной серии используют АЦП типа SAR (Successive Approximation Register). Его принцип работы основывается на пошаговом сравнении входного напряжения с эталонным, с постепенным уточнением результата от старшего бита к младшему.

Основные особенности АЦП STM32F411:
* Разрядность: 12 бит (0…4095), что при опоре 3.3 В даёт шаг квантования около 0.8–1 мВ на бит (зависит от конкретного режима и конфигурации).
* Диапазон измерений: от 0 В (VSSA) до VDDA (обычно 3.3 В), при условии соблюдения требований по питанию и невыхода за данные пределы.
* Скорость: тактовая частота модуля АЦП до 36 МГц. Теоретический максимум ~2.4 MSPS (миллионов выборок в секунду) в 12-битном режиме при минимальном времени выборки.
* Мультиканальность: АЦП может работать с несколькими каналами (до 19), среди которых 16 внешних и 3 внутренних (датчик температуры, опорное напряжение VREFINT, VBAT).
* Различные режимы преобразования: одиночное, непрерывное, сканирование нескольких каналов подряд, дискретный режим (разбиение сканирования на подпоследовательности).
* Триггеры запуска: программный (бит SWSTART) или аппаратный (от таймеров, внешних сигналов).
* DMA: поддержка передачи результатов в память без участия ядра (режим с DMA).
* Аналоговый сторож (Analog Watchdog): позволяет отслеживать выход результата за заданные пороги и вызывать соответствующее событие или прерывание.

Все эти особенности делают АЦП в STM32 удобным для измерения как внешних аналоговых сигналов (датчики, потенциометры), так и встроенных (температура, напряжение питания). 


== Управляющие регистры

Для настройки и контроля работы АЦП STM32F411 используются специальные регистры. Ниже перечислены основные из них, их назначение и ключевые параметры.

=== Регистр статуса (SR, ADC status register)
Регистр `ADC_SR` содержит флаги, отражающие текущее состояние модуля АЦП:
* EOC (End of Conversion) – устанавливается после завершения регулярного преобразования;
* AWD (Analog Watchdog) – сигнализирует, что результат вышел за заданные пороги;
* OVR (Overrun) – указывает, что новое значение перезаписало предыдущее до его чтения;
* STRT, JSTRT – начало преобразования (регулярного и injected соответственно).

В большинстве простых приложений обычно контролируют флаг EOC для отслеживания готовности результата.

=== Регистр управления CR1 (ADC control register 1)
`ADC_CR1` задаёт высокоуровневые настройки:
* RES[1:0] – разрядность преобразования (12, 10, 8 или 6 бит);
* SCAN – включает сканирование при работе с несколькими каналами;
* AWDCH[4:0] – номер канала для аналого-цифрового сторожа;
* AWDEN, JAWDEN – разрешение сторожа для регулярной или injected-группы;
* EOCIE, JEOCIE, AWDIE, OVRIE – биты включения прерываний (по окончании преобразования, сторожевому событию, переполнению и др.).

=== Регистр управления CR2 (ADC control register 2)
`ADC_CR2` отвечает за ключевые параметры запуска и режима работы:
* ADON – включает модуль АЦП;
* CONT – выбор непрерывного (1) или одиночного (0) режима;
* SWSTART – программный запуск регулярного преобразования;
* EXTSEL, EXTEN – выбор внешнего триггера и активного фронта;
* ALIGN – задаёт выравнивание результата (0 – вправо, 1 – влево);
* EOCS – настройка поведения флага EOC при сканировании;
* DMA, DDS – управление взаимодействием с DMA (однократным или непрерывным).

=== Регистр установки времени дискретизации (SMPRx, ADC sample time register)
Регистры `ADC_SMPR1` и `ADC_SMPR2` определяют время выборки (sample time):
* Каждый канал имеет трёхбитовое поле SMP[2:0] с вариантами от 3 до 480 тактов;
* Каналы 0…9 настраиваются в SMPR2, каналы 10…18 – в SMPR1;
* Чем выше выходное сопротивление источника или требуемая точность, тем дольше должно быть время выборки.

=== Регистр определения последовательности преобразований (SQR, ADC regular sequence register)
Регистры `ADC_SQR1`, `ADC_SQR2` и `ADC_SQR3` задают порядок и количество каналов в регулярной группе:
* L[3:0] в `ADC_SQR1` определяет длину последовательности (число каналов);
* Поля SQx в `SQR1–3` указывают номера каналов в нужной последовательности;
* При одиночном преобразовании достаточно указать один канал в SQ1 (например, `ADC_SQR3`) и установить L=0.

=== Регистр данных (DR, ADC data register)
`ADC_DR` (16-битный) хранит результат последнего законченного преобразования:
* При выравнивании вправо (ALIGN=0) младшие 12 бит содержат результат;
* Чтение `ADC_DR` сбрасывает флаг EOC и при необходимости OVR.

=== Общий регистр управления (CCR, ADC common control register)
`ADC_CCR` задаёт общие настройки для АЦП:
* ADCPRE[1:0] – предделитель тактовой частоты (делители 2, 4, 6, 8 от APB2);
* TSVREFE – включает питание внутреннего датчика температуры и опорного напряжения VREFINT;
* VBATE – разрешает измерение батареи (VBAT).


== Порядок запуска одиночного преобразования

При одиночном (single conversion) режиме АЦП выполняет одно преобразование выбранного канала и останавливается до следующего запуска. Ниже приведён общий порядок настройки:

. Включение тактирования АЦП и, при необходимости, соответствующего порта GPIO:
+
----
* В регистре RCC_APB2ENR установить бит ADC1EN (включает тактирование модуля АЦП).
* Если необходимо измерять сигнал с внешнего вывода, включить тактирование порта (GPIOx) в RCC_AHB1ENR.
----

. Настройка GPIO в аналоговый режим:
+
----
У нужного вывода (например, PA0 для канала 0) в регистре GPIOx_MODER установить биты `11₂` (аналоговый режим).
----

. Конфигурация общего регистра (CCR) при необходимости:
+
----
* ADCPRE – выбор предделителя тактовой частоты для АЦП (2, 4, 6, 8).
* TSVREFE – если нужно измерять температуру или опорное напряжение.
* VBATE – если требуется измерять напряжение батареи VBAT.
----

. Настройка основных параметров АЦП (CR1, CR2):
+
----
* CR1: 
** RES=00 (12 бит), SCAN=0 (выкл), отключить все неиспользуемые прерывания, если работа идёт в поллинговом режиме.
* CR2: 
** CONT=0 (одиночное преобразование), ALIGN=0 (выравнивание вправо).
** Убедиться, что ADON пока =0 (АЦП выключен), чтобы завершить настройку.
----

. Установка времени выборки (SMPRx):
+
----
В `ADC_SMPR1` или `ADC_SMPR2` (в зависимости от номера канала) задать нужные биты SMP[2:0]. Например, при низкоомном источнике – 15 или 28 тактов, при высокоомном (встроенный датчик температуры) – 480 тактов.
----

. Задание очереди (SQR):
+
----
В регистре `ADC_SQR3` вписать номер канала в SQ1. В `ADC_SQR1` установить L=0 (поскольку нужно одно измерение).
----

. Включение АЦП:
+
----
Установить бит ADON в CR2 (ADC_CR2::ADON = 1). Дать небольшую задержку (несколько микросекунд), чтобы модуль стабилизировался.
----

. Запуск преобразования:
+
----
Установить бит SWSTART (CR2::SWSTART = 1) для начала оцифровки.
----

. Ожидание завершения (EOC):
+
----
Проверять в ADC_SR бит EOC (End of Conversion). После его установки результат готов в ADC_DR.
----

. Чтение результата:
+
----
Считать значение из ADC_DR. При выравнивании вправо (ALIGN=0) реальные данные будут в младших 12 бит регистра. Чтение сбрасывает флаг EOC.
----

Таким образом, процесс одиночного преобразования сводится к настройке канала и запуску, после чего можно прочитать полученный результат и далее использовать его в программе (например, для вычисления напряжения или температуры).


== Создание класса для работы с АЦП

Для упрощения работы с АЦП в программе и сокрытия низкоуровневых деталей регистров, часто создают специальный класс (на C++), который:

* При инициализации (в конструкторе) настраивает модуль АЦП (включает тактирование, конфигурирует CR1, CR2, SMPR и пр.).
* Предоставляет методы чтения значения с нужного канала, например `readChannel(uint8_t channel)`.

Ниже приведён условный упрощённый пример такого класса (без учёта многих нюансов, но отражающий общую идею):

[source,cpp]
----
class ADC_Manager
{
public:
    // Конструктор — базовая инициализация АЦП
    ADC_Manager()
    {
        // 1) Включить тактирование (RCC->APB2ENR |= RCC_APB2ENR_ADC1EN).
        // 2) Настроить общий регистр (ADC->CCR) — предделитель и при необходимости бит TSVREFE.
        // 3) Установить параметры в CR1 и CR2: одиночный режим, 12 бит, выравнивание вправо и т.д.
        // 4) Установить бит ADON для включения АЦП.
    }

    // Метод чтения значения на указанном канале
    uint16_t readChannel(uint8_t channel)
    {
        // 1) Настроить время выборки (SMPRx) для данного канала.
        // 2) Записать номер канала в SQR (L=0, SQ1 = channel).
        // 3) Запустить преобразование (бит SWSTART).
        // 4) Дождаться флага EOC.
        // 5) Прочитать результат из DR и вернуть его.
        return 0; // В реальном коде здесь вернётся считанное значение.
    }
};
----

Такой класс инкапсулирует:
* Процедуру включения питания АЦП.
* Настройку регистров CR1, CR2, SMPR1/2, SQR и др.
* Запуск и завершение преобразования.

При использовании в основной программе остаётся лишь создать объект класса `ADC_Manager adc;` и вызывать `adc.readChannel(номер_канала)`, получая 12-битный результат, который при необходимости преобразуется в напряжение или в другие физические единицы. Это улучшает читаемость кода и позволяет легко менять конфигурацию АЦП (например, время выборки, разрядность) в одном месте — внутри класса.


== Измерение температуры (встроенный датчик микроконтроллера)

В STM32F411 имеется встроенный датчик температуры, подключённый к каналу ADC_IN18. Он позволяет измерять температуру кристалла МК (а не окружающей среды) и обычно используется для внутренних нужд:

. Включение датчика и настройка времени выборки
+
----
* Установить бит TSVREFE в регистре ADC_CCR, чтобы включить питание датчика температуры и внутреннего опорного напряжения.
* Задать максимальное время выборки (480 тактов, код 111) для канала 18, поскольку датчик имеет высокое выходное сопротивление.
----

. Выбор канала
+
----
В `ADC_SQR3` выбрать канал 18 (SQ1=18), в `ADC_SQR1` установить L=0 (одиночное преобразование).
----

. Запуск и чтение результата
+
----
* Установить бит ADON (ADC_CR2::ADON) для включения АЦП.
* Запустить преобразование битом SWSTART.
* Ждать флаг EOC (ADC_SR::EOC).
* Прочитать код из ADC_DR.
----

. Перевод кода в температуру
+
----
В официальном Reference Manual и Datasheet указана формула, учитывающая заводскую калибровку. Пример линейной интерполяции:

  T = 30°C + ( (Code_measured - TS_CAL1) / (TS_CAL2 - TS_CAL1) ) * (110°C - 30°C)

где:
 * TS_CAL1 — заводской калибровочный код при 30°C;
 * TS_CAL2 — заводской калибровочный код при 110°C.

Адреса калибровочных значений указаны в документации на конкретный чип. При чтении этих значений из памятью MК можно более точно вычислить температуру. В случае отсутствия точных калибровок используется упрощённая формула со средним наклоном (AvgSlope ~ 2.5 мВ/°C и V25 ~ 0.76 В при 25°C). 
----

Таким образом, измерение температуры кристалла внутри STM32F411 достаточно просто интегрируется в код, если учесть требования к времени выборки и включить питание датчика. Однако учитывайте, что показания отражают именно температуру кристалла, которая может заметно отличаться от внешней температуры. 



== Измерение напряжения на переменном резисторе

Измерение аналогового сигнала от потенциометра (переменного резистора) — классический пример использования АЦП. Обычно потенциометр подключается между питанием (3.3 В) и землёй, а середина (ползунок) идёт на вход АЦП.

. Подключение и настройка GPIO
+
----
* Убедиться, что выбранный вывод (например, PA0, соответствующий каналу 0 АЦП) переведён в аналоговый режим (MODER=11₂).
* Включить тактирование для порта A (бит GPIOAEN в RCC_AHB1ENR).
----

. Настройка АЦП
+
----
1) Включить модуль ADC1 (RCC_APB2ENR::ADC1EN).
2) Задать разрядность (12 бит), одиночный режим и выравнивание вправо (CR1 и CR2).
3) Установить разумное время выборки в SMPR (например, 15 или 28 тактов), если источник низкоомный (потенциометр обычно несколько кОм).
4) В SQR3 указать канал 0 (L=0, SQ1=0).
5) Включить АЦП битом ADON.
----

. Выполнение преобразования
+
----
* Установить бит SWSTART (ADC_CR2::SWSTART).
* Дождаться флага EOC (ADC_SR::EOC).
* Считать результат из ADC_DR.
----

. Перевод результата в напряжение
+
----
Полученное 12-битное значение (0…4095) отражает уровень от 0 до VREF (часто 3.3 В). Для перевода в вольты:

  voltage = (ADC_CODE / 4095.0f) * VREF

Например, при VREF = 3.3 В, если код 2048, то напряжение ≈ 1.65 В (примерно половина диапазона).
----

Таким образом, считывая напряжение с ползунка потенциометра, можно легко определять текущее положение регулятора. Подобное же решение используется при подключении всевозможных аналоговых датчиков, выдающих напряжение в пределах 0…3.3 В.


== Заключение

В рамках данной работы рассмотрено, как в микроконтроллере STM32F411 организован и используется 12-битный АЦП типа SAR. Показано, что АЦП способен быстро и с достаточной точностью оцифровывать различные аналоговые сигналы: от встроенного датчика температуры до напряжения на внешнем потенциометре. Ключевые моменты, которые необходимо учитывать:

* Тонкости настройки регистров управления (CR1, CR2), времени выборки (SMPR1/2), а также последовательности каналов (SQR).
* Включение тактирования модуля АЦП и перевод соответствующего вывода в аналоговый режим.
* Возможность использования одного или нескольких каналов, а также специального режима для внутреннего датчика температуры.
* Необходимость корректного времени выборки для высокоомных источников (например, встроенный термосенсор).
* Предусмотренная поддержка DMA и прерываний, упрощающая обработку больших массивов данных и асинхронную работу.
* Функция аналогового сторожа, позволяющая автоматически реагировать на выход сигнала за установленные пределы.

Для удобства реализации на практике полезно оборачивать логику управления АЦП в отдельный класс, скрывающий детали настройки регистров и предоставляющий метод для быстрого чтения данных. Это повышает читаемость и надёжность кода.

Таким образом, правильно настроенный и эффективно используемый АЦП даёт возможность взаимодействовать с широким спектром аналоговых датчиков и сигналов, обеспечивая гибкость и функциональность во множестве встроенных приложений.

[source,cpp]
----
#include "rccregisters.hpp"    // for RCC
#include "gpioaregisters.hpp"  // for GPIOA
#include "gpiocregisters.hpp"  // for GPIOC
#include <array>
#include <cstdint>
#include "adc1registers.hpp"   // for ADC CR1
#include <iostream>

#include "stkregisters.hpp"    // for SystemTimer
#include "scbregisters.hpp"    // for ISCR register
#include "tim2registers.hpp"

#include "ILed.h"
#include "Led.h"
#include "ledconfig.h"

#include "IMode.h"
#include "allmode.h"
#include "treemode.h"
#include "chessmode.h"
#include "modeconfig.h"
#include "IButton.h"
#include "Button.h"
#include "IModeManager.h"
#include "modeconfig.h"
#include "ModeManager.h"
#include "ButtonExti.h"
#include "ModeManagerConfig.h"
#include "syscfgregisters.hpp"
#include "extiregisters.hpp"
#include "nvicregisters.hpp"   // for NVIC
#include "tim5registers.hpp"   // for TIM5

std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
  // while (RCC::CR::HSIRDY::NotReady::IsSet()) { }
  RCC::CFGR::SW::Hsi::Set();
  // while (!RCC::CFGR::SWS::Hsi::IsSet()) { }

  RCC::APB2ENR::SYSCFGEN::Enable::Set();
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB1ENR::TIM5EN::Enable::Set();

  NVIC::ISER1::Write(1 << 18U);

  const auto TimerDivider = SystemCoreClock / 1'000U;

  TIM5::PSC::Write(TimerDivider);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(500U);
  TIM5::SR::UIF::Set(0);
  TIM5::CNT::Write(0);
  TIM5::DIER::UIE::Value1::Set();
  TIM5::CR1::CEN::Enable::Set();

  return 1;
}
}

bool isInterruptHappened = false;

int main()
{
  // Подаём тактирование на порт A
  RCC::AHB1ENR::GPIOAEN::Enable::Set();
  // Подаём тактирование на порт C
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  
  // Порт A.5 на вывод
  GPIOA::MODER::MODER5::Output::Set();
  // Порт C.5, C.8, C.9 на вывод
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();
  GPIOC::MODER::MODER9::Output::Set();

  // Создаём объект кнопки, привязанной к выводу PC13 (EXTI)
  ButtonExti<GPIOC, 13> button;

  // Создаём объекты светодиодов
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  // Собираем их в массив
  tLeds leds = { &led1, &led2, &led3, &led4 };

  // Создаём разные режимы (пример демонстрационной логики)
  AllMode allmode(leds);
  ChessMode chessmode(leds);
  TreeMode treemode(leds);

  // Список режимов для диспетчера
  tMode MODES = {
    &allmode,
    &chessmode,
    &treemode
  };

  // Создаём диспетчер режимов
  ModeManager modeManager(MODES);
  modeManager.InitModeManager();

  // Основной цикл
  for(;;)
  {
    if (isInterruptHappened)
    {
      // Обновление состояния режимов
      modeManager.UpdateModeManager();

      // Проверяем нажатие кнопки
      if(button.onClick())
      {
        // Переключаемся на следующий режим
        modeManager.SwitchModeManager();
      }
      isInterruptHappened = false;
    }
  }

  return 1;
}
----


