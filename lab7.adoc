= Лабораторная работа 7
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица

== Вcтроенные таймеры для платы STM32F411RET6

Микроконтроллер STM32F411RET6  включает в себя различные таймеры, предназначенные для выполнения разнообразных задач.

Системный таймер SysTick — это базовый таймер, встроенный в ядро Cortex-M4. Он используется для системного времени и генерации прерываний через заданные промежутки. SysTick применяется, например, в операционных системах реального времени (RTOS) или для функции HAL_Delay в библиотеке HAL.

Общие таймеры (General-Purpose Timers) универсальны и подходят для задач, таких как измерение времени, генерация ШИМ, захват и сравнение сигналов. В STM32F411RET6 доступны:

. TIM2 и TIM5 — 32-битные таймеры для работы с длительными временными интервалами.
. TIM3 и TIM4 — 16-битные таймеры, применяемые для более простых задач.
Таймеры для расширенного управления (Advanced-Control Timers) предназначены для управления двигателями и сложной генерации ШИМ-сигналов. В STM32F411RET6 есть один такой таймер: TIM1, который является 16-битным с возможностями синхронизации, dead-time вставки и комплементарными выходами.

. Базовые таймеры (Basic Timers), такие как TIM6 и TIM7, служат для генерации периодических прерываний или в качестве триггеров для других периферийных устройств. Они не требуют входных или выходных сигналов.

. Специальные таймеры (Specialized Timers) используются для работы с аудиопотоками или сложной временной синхронизации. В микроконтроллере STM32F411RET6 присутствуют таймеры TIM9, TIM10 и TIM11, которые являются 16-битными и часто применяются для менее требовательных задач.

Системный таймер SysTick в STM32F411RET6 предназначен для генерации регулярных прерываний, используемых для реализации системного времени или задач с фиксированным интервалом. Управление таймером осуществляется через настройки регистров и встроенные функции ядра Cortex-M4.

Для инициализации SysTick необходимо настроить несколько регистров:  
*SysTick Reload Value Register (SYST_RVR)* — задаёт максимальное значение счётчика, после которого происходит обнуление и генерация прерывания. Это значение определяет период таймера.  *SysTick Control and Status Register (SYST_CSR)* — используется для включения/выключения таймера, выбора источника тактирования и управления прерываниями.

SysTick может работать от двух источников тактирования:  

* Процессорный тактовый сигнал (HCLK), обеспечивающий высокую точность.  
* HCLK/8, что снижает энергопотребление и частоту работы таймера.  

Выбор источника тактирования осуществляется с помощью бита *CLKSOURCE* в регистре *SYST_CSR*.

Запуск таймера производится установкой следующих битов:  

* *ENABLE* в регистре *SYST_CSR* — для включения таймера.  
* *TICKINT* — для активации генерации прерываний.

Когда таймер достигает заданного значения (нулевого состояния счётчика), он генерирует прерывание. Для обработки прерывания необходимо:  

* Настроить функцию-обработчик в таблице векторов прерываний. Обычно используется функция *SysTick_Handler*.  
* Реализовать логику в обработчике, например, инкремент глобального счётчика времени или выполнение периодической задачи.

== Работа с системным таймером

Был подключен системный таймер с помощью следующих команд:

[source, cpp]
----
#include "stkregisters.hpp" // for SystemTimer
#include "scbregisters.hpp" // for ISCR register
----


Далее была реализована функция delay() c  помощью системного таймера. delay() использует системный таймер SysTick для реализации программной задержки. Таймер настраивается на заданное время в миллисекундах, запускается, и функция блокирует выполнение программы до истечения задержки. Такой подход обеспечивает точность, зависящую от системной частоты SystemCoreClock.

[source, cpp]
----

void delay(uint32_t mseconds)
{
  assert (mseconds < 10000);
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * mseconds;
  STK::LOAD::Write(timerDelayCounts - 1);
  STK::VAL::Write(0);
  STK::CTRL::ENABLE::Enable::Set();

    while(STK::CTRL::COUNTFLAG::NoOverflow::IsSet())
    {
    }
  
   STK::CTRL::ENABLE::Disable;
}

----


Код main():

[source, cpp]
----

int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  
  Button <GPIOC, 13> button;

  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;
  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};
    
    
    AllMode allmode(leds);
    ChessMode chessmode(leds);
    TreeMode treemode(leds);
    
    tMode MODES = {
    &allmode,  
    &chessmode,
    &treemode  
    };
    ModeManager modeManager(MODES);
    modeManager.InitModeManager();

  for(;;) 
  {

    modeManager.UpdateModeManager();
    
    if(button.isClick())
    {
      modeManager.SwitchModeManager();
    }
    delay(300);
  }
    
  return 1;
}

----


== Настройка таймера TIM5

TIM5 в микроконтроллере STM32F411RET6 — это 32-битный таймер общего назначения (General-Purpose Timer), предоставляющий широкие возможности для измерения времени, генерации сигналов, работы с прерываниями и управления периферийными устройствами.

Основные характеристики TIM5:

* *Разрядность*: 32-битный счётчик, позволяющий работать с длинными временными интервалами.

* *Тактовый сигнал*: Таймер может работать с тактовой частотой, выбираемой из APB1 шины или с помощью внутреннего предделителя.

* *Режимы работы*: Поддерживает временной базис, Input Capture (захват входного сигнала), Output Compare (сравнение выхода) и генерацию ШИМ.
 
* *События и прерывания*: Генерирует прерывания и события при переполнении счётчика, совпадении значения и других условиях.  

Основные регистры TIM5:  
. *TIMx_CR1 (Control Register 1)* — управляет основными функциями таймера, такими как направление счёта (вперёд или назад), выравнивание центра или края, а также режим работы.

. *TIMx_CNT (Counter Register)* — хранит текущее значение счётчика.

. *TIMx_ARR (Auto-Reload Register)* — определяет максимальное значение счётчика. По достижении этого значения таймер сбрасывается или переполняется.

. *TIMx_PSC (Prescaler Register)* — устанавливает предделитель, уменьшающий частоту тактового сигнала для таймера. 

. *TIMx_CCRx (Capture/Compare Registers)* — используются для захвата входных сигналов или генерации выходных. 

. *TIMx_SR (Status Register)* — отображает состояние таймера, включая флаги событий, например, флаг переполнения.


 
. *TIMx_DIER (DMA/Interrupt Enable Register)* — управляет включением прерываний или событий DMA.  

Режимы работы TIM5:

. *Time Base* — таймер создаёт регулярные события, например, генерирует прерывания через заданные промежутки времени.

. *Input Capture* — фиксирует значение счётчика в момент прихода внешнего сигнала, что удобно для измерения ширины импульсов или периода сигнала.

. *Output Compare* — сравнивает текущее значение счётчика с установленным значением в регистре и генерирует событие при совпадении, используется для точного управления выходами.

. *ШИМ (PWM)* — генерирует широтно-импульсную модуляцию с точным управлением шириной импульса.  

Пример использования TIM5 для генерации прерываний:

. Настройте таймер для работы в режиме Time Base.
 
. Установите предделитель в *TIMx_PSC* и значение автоперезагрузки в *TIMx_ARR*.

. Включите флаг прерывания в регистре *TIMx_DIER*.


Применения TIM5: 

* Тайминг событий с высокой точностью благодаря 32-битному счётчику.

* Измерение длительности или периода сигналов.

* Генерация ШИМ-сигналов для управления устройствами, такими как двигатели.

* Организация периодических задач в системах реального времени.  

TIM5 — это универсальный и мощный инструмент для задач, требующих точного контроля времени или синхронизации.

Разработка функции delay() на основе таймера TIM5.

Подключение таймера:

[source, cpp]
----
#include "tim5registers.hpp"

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }
  RCC::APB1ENR::TIM5EN::Enable::Set();
  return 1;
}
----



Функция реализует задержку с использованием таймера TIM5 микроконтроллера. Она проверяет корректность входного значения mseconds, настраивает таймер: предделитель для работы с миллисекундами, регистры автоперезагрузки (ARR) и счетчика (CNT), очищает флаг прерывания (UIF) и запускает таймер. Далее функция в цикле ожидает завершения заданного количества тактов, проверяя состояние флага прерывания. После выполнения задержки таймер отключается, а флаг прерывания сбрасывается:


[source, cpp]
----
void delay(uint32_t mseconds)
{
  assert (mseconds < 10000);
  const auto timerDelayCounts = (SystemCoreClock / 1000U) * mseconds;
  TIM5::PSC::Write(timerDelayCounts-1U);
  TIM5::CR1::URS::Value1::Set();
  TIM5::ARR::Write(mseconds);
  TIM5::CNT::Write(0);
  TIM5::SR::UIF::Set(0);
  TIM5::CR1::CEN::Enable::Set(); 
    while(TIM5::SR::UIF::NoInterruptPending::IsSet())
    {
    }
   TIM5::CR1::CEN::Disable::Set();
   TIM5::SR::UIF::Set(0);
}
----


