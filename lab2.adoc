= Лабораторная работа №2
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица


== Типы данных

Тип данных — это характеристика переменной, определяющая, какие значения она может хранить и какие операции с ней допустимы. Более подробно представлено на диаграмме <<picTD>>.


.Типы данных в С++
[#picTD]
image::pic_TD.png[]

**Простые типы данных:**

Целые (Integral types):

- bool: логический тип данных, который может принимать два значения — true или false.
- char: тип данных для хранения символов или небольших целых чисел.
- int: основной тип для хранения целых чисел.
enum: Перечисление, которое используется для создания набора именованных целочисленных констант.
- long: тип данных для хранения целых чисел большего диапазона.
short: тип данных для хранения целых чисел меньшего диапазона.
- long long: тип для хранения очень больших целых чисел, большего диапазона, чем long.
- unsigned: Модификатор, который используется для целочисленных типов для представления только неотрицательных чисел.

С плавающей точкой (Floating-point types):

- float: тип данных для хранения чисел с плавающей запятой одинарной точности.
- double: тип данных для хранения чисел с плавающей запятой двойной точности.
- long double: тип данных для хранения чисел с плавающей запятой с еще большей точностью, чем double.

**Структурированные типы данных:**

- array (массив): структура данных, которая хранит набор элементов одного и того же типа.
- union (объединение): тип данных, в котором несколько переменных могут использовать одну и ту же область памяти, но только одно из этих значений может храниться в любой момент времени.
- class/structure (класс/структура): пользовательский тип данных, который может содержать переменные (поля) и методы, объединяя разные типы данных в одну сущность.

**Адресные типы данных:**

- pointer (указатель): тип данных, который хранит адрес другой переменной или объекта в памяти.
- reference (ссылка): тип данных, который является альтернативой указателю, представляя собой ссылку на другой объект.

== Смешивание типов данных и к чему это приводит

Смешивание типов данных может привести к потере данных или точности, когда значения преобразуются из одного типа в другой с меньшим диапазоном или точностью, как, например, при преобразовании double в int. Это может вызвать ошибки в логике программы, непредсказуемые результаты или даже сбои, особенно если неявное преобразование выполняется автоматически, без явного контроля со стороны программиста. Явное приведение типов помогает избежать таких проблем, делая код более предсказуемым.

== Неявное преобразование типов
Неявное преобразование типов — это автоматическое преобразование, которое выполняется компилятором или интерпретатором, когда разные типы данных используются в одной операции. Программа сама решает, как привести типы к совместимому виду. Пример: при сложении int и double целое число автоматически преобразуется в double.


[source, cpp]
----
int main() {
    int a = 10;
    double b = 5.5;
    double result = a + b;  // Неявное преобразование int в double
    std::cout << "Неявное преобразование: " << result << std::endl;  // Выведет: 15.5
    return 0;
}
----
== Явное преобразование типов

Явное преобразование типов — это процесс, при котором программист вручную указывает, что значение должно быть преобразовано в другой тип данных. Это делается с использованием специального синтаксиса, например, приведение через скобки в C/C++ или встроенные функции в других языках. Пример: (int) 3.14 — дробная часть числа будет отброшена, результатом станет 3.


[source, cpp]
----
 // Приведение double к int с помощью static_cast

    double num = 9.7;
    int intNum = static_cast<int>(num);

// Вывод: intNum: 9
----

== Размеры типов

В таблице <<Встроенные типы>> представлены соответствия типов данных и их размеров в байтах для стандартных типов данных. В качестве платформы-компилятора рассматривается IAR Workbench. Компилятор имеет 32 битную архитектуру.
Важно отметить, что точные значения зависят от платформы. На большинстве платформ с 32-битной архитектурой

sizeof(char) == 1 (1 байт)

sizeof(short) == 2 (2 байта)

sizeof(int) == 4 (4 байта)

sizeof(long) == 4 (4 байта)

sizeof(long long) == 8 (8 байт)

sizeof(float) == 4 (4 байта)

sizeof(double) == 8 (8 байт)

sizeof(long double) может варьироваться (например, 8, 10, 16 байт)

Ниже в таблице представлены встроенные типы данных для рассматриваемого компилятора.

[#Встроенные типы ]
.Встроенные типы 
[options="header"]
[cols="2,1,7"]
|============
| *Тип данных*           | *Размер (байт)* | *Диапазон значений*

| *bool*          | 1  | false (0) или true (1)
| *char*             | 1 | От -128 до 127 (signed) или от 0 до 255 (unsigned)
| *wchar_t*     | 4    | От 0 до 4,294,967,295 (широкие символы)
| *short*  | 2       | От -32,768 до 32,767
| *unsigned short*  | 2     | От 0 до 65,535
| *int*    | 4  | От -2,147,483,648 до 2,147,483,647
| *unsigned int* | 4 | От 0 до 4,294,967,295
| *long*    | 4  | От -2,147,483,648 до 2,147,483,647
| *unsigned long*   | 4 | От 0 до 4,294,967,295
| *long long*            | 8 | От -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807
| *unsigned long long*  | 8    | От 0 до 18,446,744,073,709,551,615
| *float*    | 4   | ~7 значащих цифр
| *double*    | 8    | ~15 значащих цифр
| *long double*    | 8    | ~15 значащих цифр
| *std::int8_t*    | 1    | От -128 до 127
| *std::uint8_t*   | 1     | От 0 до 255
| *std::int16_t*      | 2  | От -32,768 до 32,767
| *std::uint16_t*    | 2    | От 0 до 65,535
| *std::int32_t*     | 4    | От -2,147,483,648 до 2,147,483,647
| *std::uint32_t*    | 4   | От 0 до 4,294,967,295
| *std::int64_t*     | 8     | От -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807
| *std::uint64_t*   | 8     | От 0 до 18,446,744,073,709,551,615
|============

== Функции преобразования

*Функция static_cast*

static_cast используется для безопасного и явного приведения типов, которые логически совместимы. Он подходит для преобразования между базовыми и производными классами, примитивными типами (например, int в float), а также для приведения указателей к базовым типам. Это более безопасное приведение, так как компилятор проверяет правильность преобразования на этапе компиляции.

Пример: 

[source, cpp]
----
 // Приведение double к int с помощью static_cast

    double num = 9.7;
    int intNum = static_cast<int>(num);

// Вывод: intNum: 9

----

*Функция reinterpret_cast*

reinterpret_cast применяется для низкоуровневого преобразования между несвязанными типами, такими как указатели на разные типы данных (например, преобразование указателя на int в указатель на char). Это небезопасное преобразование, так как оно не проверяет совместимость типов, а лишь интерпретирует биты одного типа как другого. Использование этого оператора требует осторожности, так как может привести к непредсказуемым результатам.

Пример: 

[source, cpp]
----
   // Преобразование указателя на int в указатель на char

    int num = 42;
    char* ptr = reinterpret_cast<char*>(&num);
    
    // Вывод: 42 (или 0 в зависимости от порядка байтов)
----

== Как распределяется память ОЗУ в микроконтроллере

Посегменто память ОЗУ в микроконтроллере распределяется на:

. Сегмент программного кода — область памяти, содержащая исполняемый код программы, обычно хранящийся во флэш-памяти и не изменяющийся во время выполнения.

. Сегмент данных используется для хранения глобальных и статических переменных, делится на инициализированные данные (с заданными значениями) и неинициализированные данные (BSS), которые инициализируются нулями.

. Сегмент стека предназначен для хранения локальных переменных, адресов возврата и временных данных. Стек работает по принципу "последний пришёл — первый вышел" и растёт вниз от верхней границы доступной памяти.

. Сегмент кучи  используется для динамического распределения памяти во время выполнения программы.

. Глобальные и статические переменные хранятся в сегменте данных, который делится на инициализированные и неинициализированные области. Инициализированные переменные размещаются в одной части сегмента данных, в то время как неинициализированные размещаются в другой части и инициализируются нулями при запуске программы.

Вся память микроконтроллера имеет 4 Гбайта последовательной памяти с адресами от 0x00000000 до 0xFFFFFFFF.

Адресное пространство памяти программы (ПЗУ) находится по адресам 0x00000000 по 0x1FFFFFFF.

Адресное пространство ОЗУ находится по адресам 0x20000000 по 0x3FFFFFFF.

Адресное пространство для регистров периферии находится по адресам с 0x40000000 по 0x5FFFFFFF.
== Указатель

Указатель — это переменная, содержащая адрес другой переменной в памяти. Каждой переменной, хранящей данные, соответствует определенный адрес памяти. К переменной можно обратиться напрямую, используя её имя, что позволяет непосредственно читать или записывать значение по её адресу. Кроме того, можно обратиться к переменной косвенно, используя указатель или ссылку.

Пример: 

[source, cpp]
----
    int num = 1;          // Объявляем переменную
    int* ptr = &num;      // Создаём указатель и инициализируем его адресом переменной num
    *ptr = 100;    // Изменяем значение переменной через указатель
    // ВЫвод: 100
----

Основные функции указателя:

- Хранение адресов переменных.
- Косвенный доступ к данным.
- Динамическое распределение памяти.
- Передача переменных в функции по ссылке.
- Работа с массивами.
- Использование многоуровневых указателей.
- Создание ссылочных типов для управления объектами.

== Регистр
Регистр — это небольшая, высокоскоростная память внутри центрального процессора (ЦП), используемая для хранения данных и инструкций, которые процессор обрабатывает в данный момент времени. Регистры играют ключевую роль в архитектуре компьютера и выполняют следующие функции:

- Хранение временных данных, необходимых для выполнения операций.
- Сохранение адресов памяти, указывающих, где находятся данные.
- Выполнение арифметических и логических операций, что позволяет процессору быстро манипулировать данными.

Регистры имеют фиксированный размер, который зависит от архитектуры процессора и обеспечивают значительно более высокую скорость доступа по сравнению с другими типами памяти, такими как кэш или оперативная память.

== Логические операции 
Дизъюнкция — это логическая операция, обозначаемая символом V(|) или словом "или". Она принимает два булевых значения (истина или ложь) и возвращает истину, если хотя бы одно из значений истинно. 

.Таблица истинности (Дизъюнкция)
[cols="1,1,1", options="header"]
|=====
| A  | B  | A V B

| ИСТИНА | ИСТИНА | ИСТИНА
| ИСТИНА | ЛОЖЬ  | ИСТИНА
| ЛОЖЬ | ИСТИНА | ИСТИНА
| ЛОЖЬ | ЛОЖЬ | ЛОЖЬ
|=====

Конъюнкция — это логическая операция, обозначаемая символом ∧(&) или словом "и". Она также принимает два булевых значения и возвращает истину только тогда, когда оба значения истинны.

[cols="1,1,1", options="header"]
|=====
| A | B | A ∧ B

| ИСТИНА | ИСТИНА | ИСТИНА
| ИСТИНА | ЛОЖЬ | ЛОЖЬ
| ЛОЖЬ | ИСТИНА | ЛОЖЬ
| ЛОЖЬ | ЛОЖЬ | ЛОЖЬ
|=====

== Сборс бита

Операция сброса бита — это операция, которая изменяет значение определённого бита в числе на 0, не затрагивая остальные биты. Эта операция обычно выполняется с помощью побитовой операции И (AND) с маской, в которой целевой бит равен 0, а все остальные биты равны 1.

Пример:

[source, cpp]
----
    unsigned char num = 0b10101100; // Исходное число: 172 в десятичной системе
    int bitPosition = 3; // Позиция бита для сброса 

    // Создание маски для сброса нужного бита
    unsigned char mask = ~(1 << bitPosition); // Маска: 11110111

    // Сброс бита с помощью побитовой операции AND
    unsigned char result = num & mask; // Результат: 10100100
----

== Ответы на вопросы


1) Если указатель типа int указывает на адрес 1 и к этому указателю прибавит 1, то на какой адрес будет указывать указатель и почему? Для типа double?

*Ответ:* 

Для указателя типа int: при добавлении 1 указатель будет равен *5*, так как указатель типа int равен числу указателя переменоженного на размерз указателя, т.е. 1*4(байта - размер указателя int), после чего добавляется число 1. 

Для указателя типа double: аналогично предыдущему ответу: 1*8+1=9. Ответ: 9.

2) Если в ячейке по адресу 1 лежит число 10, в ячейке по адресу 2 лежит число 20, в ячейке по адресу 3 лежит число 30, в ячейке по адресу 4 лежит число 40 и если у нас указатель типа std::uint32_t указывает на адрес 1, то какое число будет в переменной b после разименовывания указателя?

*Ответ:* 

Т.к. размер  uint32_t 4 байта, то в ячейке будет лежать адресное число записанное в каждом адресе начиная со старшего байта: 0x281E140А или 673059850.

3) Определить

[source,cpp]
----
std::uint32_t ptr* = reinterpret_cast<std::uin32_t>(1);

auto b = *ptr; //чему равно b?
----
*Ответ:* Выведет ошибку, так как происходит попытка разыменовывания указателя (ошибка доступа к памяти). В системах с порядком байт little-endian младший байт (10) размещается по младшему адресу (1), а старшие байты следуют по возрастающим адресам. В таком порядке переменная b после разыменовывания принимает значение 673720842

4) Определить

[source,cpp]
----
std::uint16_t* ptr = reinterpret_cast<std::uin16_t>(1);

auto b = *ptr; //чему равно b?
----

*Ответ:* Выведет ошибку, так как происходит попытка разыменовывания указателя (ошибка доступа к памяти). в других системах: std::uint16_t, ссылаясь на адрес 1, считывает два байта (10 и 20), образуя число 5130.

5)
auto b = "c";  //Задание на дом. Какого типа b?

*Ответ:* указатель типа `const char*`


 auto b1 = 'c';  //Задание на дом. Какого типа b1? 


*Ответ:* b1 будет иметь значение типа `char`


 char a = 'A';  //Задание на дом, в какое число переведется символ А


*Ответ:* число 65 



== Выводы по работе

В ходе выполнения лабораторной работы были изучены основные типы данных в C++ и их характеристики, включая размеры и диапазоны значений. Простые типы данных, такие как целые числа и числа с плавающей запятой, позволяют хранить значения различной точности и диапазона. Структурированные и адресные типы данных, такие как массивы, указатели и классы, обеспечивают более сложные способы работы с данными, позволяя объединять значения разных типов или работать с адресами памяти.

Особое внимание уделено вопросам преобразования типов. Неявное преобразование, выполняемое автоматически компилятором, может привести к потере точности или ошибкам, если типы данных несовместимы. Явное преобразование предоставляет программисту полный контроль над этим процессом, делая код более предсказуемым и безопасным. Для этих целей были рассмотрены инструменты, такие как static_cast и reinterpret_cast.

Также изучено распределение памяти в микроконтроллере. Память делится на сегменты, включая код программы, данные, стек и кучу, каждый из которых выполняет свою функцию. Это понимание позволяет эффективно управлять ресурсами памяти, минимизируя её избыточное использование и избегая конфликтов. Кроме того, рассмотрены указатели, их использование для косвенного доступа к данным, динамического распределения памяти и взаимодействия с функциями. Указатели обеспечивают гибкость, но требуют осторожности, чтобы избежать ошибок работы с памятью.

Дополнительно освещены логические операции, такие как дизъюнкция и конъюнкция, а также их применение в программировании. Логические выражения позволяют обрабатывать булевы значения, что важно при реализации условий и алгоритмов.

В работе также проведён анализ операций с памятью, включая сброс отдельных битов. Это демонстрирует применение побитовых операций для управления данными на низком уровне. Были рассмотрены ответы на вопросы, связанные с адресацией и разыменованием указателей, а также преобразованием символов в числовые значения, что подтверждает глубокое понимание работы с памятью и типами данных.

Лабораторная работа помогла закрепить теоретические знания и приобрести практические навыки работы с различными аспектами программирования на C++, что особенно важно для работы с микроконтроллерами и низкоуровневой обработкой данных.