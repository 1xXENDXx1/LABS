= Лабораторная работа 9
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица


include::titulnik9.adoc[]



== Архитектура контроллера прерываний NVIC и блока EXTI

В микроконтроллерах STM32F4 (ядро Cortex-M4) аппаратный модуль NVIC (Nested Vectored Interrupt Controller – вложенный векторный контроллер прерываний) отвечает за управление внешними прерываниями. NVIC встроен в ядро и способен обслуживать десятки линий прерываний с разными уровнями приоритета. В STM32F411 имеется порядка 82 маскируемых каналов прерываний (IRQ) в NVIC, каждый из которых связан с конкретным устройством (таймер, USART, DMA и т.д.) или с группой линий внешних прерываний EXTI.

NVIC позволяет прерываниям быть вложенными: прерывание с более высоким приоритетом может прервать обработчик более низкоприоритетного прерывания (если разрешено вложение). Логика приоритета в NVIC определяется 4-битными значениями приоритета для каждого канала (0 – самый высокий приоритет, 15 – самый низкий, по умолчанию). Кроме того, NVIC поддерживает группировку приоритетов (разделение на приоритет предвещения и подприоритет), однако по умолчанию вся 4-битная градация используется как уровень приоритета без подприоритетов.

Блок EXTI (External Interrupt/Event Controller – контроллер внешних прерываний/событий) является периферийным модулем, который отслеживает изменения сигналов на определённых выводах GPIO и формирует запросы прерывания в NVIC. EXTI можно представить как мультиплексор, на входы которого приходят линии от выводов различных портов, а на выходе – сигнал запроса в NVIC. В STM32F4 имеется 16 линий EXTI, пронумерованных 0–15, которые могут быть сопоставлены выводам PAx, PBx, PCx и т.д. с тем же номером x. Например, линия EXTI13 может быть подключена к одному из выводов P_13 (порт A13, B13, C13 и т.д.) в зависимости от настроек.

Каждая линия EXTI имеет свой бит pending (флаг состояния, сигнализирующий о случившемся событии) и может быть настроена на реагирование по нарастающему и/или спадающему фронту сигнала. Взаимодействие между GPIO, EXTI и NVIC происходит следующим образом: при изменении логического уровня на конфигурированном выводе GPIO (например, кнопка на PC13) сигнал поступает на соответствующую линию EXTI, где детектор фронта фиксирует событие (устанавливает pending-флаг). Контроллер EXTI, в свою очередь, при незамаскированной линии формирует запрос прерывания в NVIC по предопределённому каналу IRQ. NVIC получает этот запрос (если глобально разрешены прерывания в процессоре) и, с учётом приоритета, прерывает основной поток исполнения, передавая управление обработчику прерывания, адрес которого хранится в таблице векторов.


NVIC, получив запрос, смотрит приоритет: если прерывание разрешено (не замаскировано) и имеет достаточный приоритет, процессор откладывает выполнение текущего кода и переходит по вектору обработчика EXTI15_10_IRQn. После этого начинается выполнение функции-обработчика (ISR) данного прерывания.

Стоит отметить, что из 16 линий EXTI не все имеют уникальные каналы в NVIC: линии 0–4 имеют отдельные IRQ (EXTI0_IRQn, EXTI1_IRQn и т.д.), линии 5–9 объединены в один канал EXTI9_5_IRQn, а линии 10–15 – в канал EXTI15_10_IRQn. Это означает, что, например, события на PC13 и PA14 (линии 13 и 14) оба вызовут один и тот же обработчик EXTI15_10_IRQHandler. Внутри общего обработчика потребуется проверить, какая именно линия установила флаг, и обработать каждую. Такая группировка используется для оптимизации числа векторов прерывания.

Логика приоритета и обработка в NVIC: NVIC хранит для каждого канала IRQ свой бит разрешения (в регистрах ISER – Interrupt Set Enable Registers) и значение приоритета (в массивах регистров IPR). При наступлении события EXTI контроллер NVIC выставляет бит pending соответствующего IRQ. Если данный IRQ разрешён и имеет более высокий приоритет (численно меньший), чем текущее выполняемое прерывание, то процессор выполнит предварительное прерывание текущего потока и запустит обработчик нового прерывания. NVIC автоматически берёт номер IRQ (например, EXTI15_10_IRQn) и находит адрес обработчика в таблице векторов, после чего CPU начинает исполнять этот обработчик.

В Cortex-M4 также реализована функция *tail-chaining* – если во время обработки одного прерывания поступает другой запрос с более высоким приоритетом, переключение происходит немедленно по завершении текущего обработчика без возврата в основной код, что уменьшает задержки. Если же несколько прерываний поступили одновременно с одинаковым приоритетом, у NVIC есть фиксированный порядок разрешения коллизий (в первую очередь обслуживается прерывание с меньшим номером IRQ).

В случае STM32F411 линии EXTI10–15 имеют один IRQ номер (связанный с вектором 40 в таблице прерываний NVIC). При одновременном нажатии нескольких кнопок, подключенных к разным линиям из диапазона 10–15, NVIC воспримет это как одно прерывание EXTI15_10. Обработчик должен в такой ситуации опросить регистр Pending (PR) контроллера EXTI и определить, какие конкретно линии установлены, затем поочерёдно их сбросить и обработать.

Таким образом, NVIC и EXTI совместно обеспечивают приоритетную обработку внешних сигналов, позволяя системе реагировать на нажатие кнопки в любом месте программы практически мгновенно и в нужном порядке приоритетов.

== Назначение и взаимодействие классов проекта

Проект реализован с использованием объектно-ориентированного и шаблонного подхода, что обеспечивает гибкость и переиспользуемость компонентов. Все компоненты независимы и обмениваются действиями через вызовы методов:

* `ButtonExti` — шаблонный класс, обрабатывающий внешнее прерывание. Вызывает метод `SwitchModeManager` у переданного менеджера режима.
* `ModeManager` — управляет текущим режимом, позволяет переключаться между режимами (например, AllMode, ChessMode, TreeMode), и инициировать обновление текущего состояния.
* `Timer` — шаблонный класс, привязанный к периферийному таймеру (TIM2, TIM5), реализует периодическое прерывание, вызывающее метод `UpdateModeManager`.

Класс `ModeManager` является точкой концентрации логики, взаимодействующей как с кнопкой (через `SwitchModeManager`), так и с таймером (через `UpdateModeManager`), тем самым реализуя динамическую смену состояния по событиям.

== Последовательность настройки EXTI13

Чтобы реализовать обработку сигнала от кнопки, необходимо настроить EXTI13. Последовательность включает в себя несколько обязательных шагов:

. Настройка порта GPIOC, пин 13, как входного.
. Разрешение тактирования модуля SYSCFG для конфигурации внешнего источника.
. Привязка линии EXTI13 к PC13 через SYSCFG_EXTICR4.
. Разрешение срабатывания по спадающему фронту.
. Разрешение линии в регистре маски EXTI_IMR.
. Сброс флага ожидания в регистре EXTI_PR.
. Активация соответствующего вектора в NVIC.

Пример кода:

[source,cpp]
----
RCC::AHB1ENR::GPIOCEN::Enable::Set();
GPIOC::MODER::MODER13::Input::Set();

RCC::APB2ENR::SYSCFGEN::Enable::Set();
SYSCFG::EXTICR4::EXTI13::Value2::Set();

EXTI::FTSR::TR13::Value1::Set();
EXTI::RTSR::TR13::Value0::Set();
EXTI::PR::PR13::Value1::Set();
EXTI::IMR::MR13::Value1::Set();

NVIC::ISER1::Write(1 << 8U); // EXTI15_10
----

== Обработчик нажатия кнопки

Обработчик реализован в классе `ButtonExti`, привязывается к вектору EXTI15_10. Он проверяет, был ли действительно вызван EXTI13, вызывает переключение режима и сбрасывает флаг:

[source,cpp]
----
template<auto &modeManager>
class ButtonExti {
public:
    static void HandleClick() {
        if (EXTI::PR::PR13::Value1::IsSet()) {
            modeManager.SwitchModeManager();
            EXTI::PR::PR13::Value1::Set();
        }
    }
};
----

== Таймер: синхронизация с периодом

Для обеспечения обновления состояния используется таймер TIM5. Он настраивается на генерацию прерывания каждые 500 мс. При срабатывании вызывается метод `UpdateModeManager`, что позволяет визуально наблюдать за действием выбранного режима (например, мигание светодиодов).

[source,cpp]
----
TIM5::PSC::Write(SystemCoreClock / 1000U);
TIM5::ARR::Write(500U);
TIM5::DIER::UIE::Value1::Set();
TIM5::CR1::CEN::Enable::Set();
----

== Таблица прерываний

Векторная таблица на этапе компиляции формируется с привязкой конкретных обработчиков к точкам входа. EXTI13 входит в группу EXTI15_10. В таблице:

[source,cpp]
----
ButtonExti<modeManager>::HandleClick,     // EXTI15_10
Timer<TIM5, modeManager>::OverloadHandler // TIM5
----

== Диаграмма последовательности (PlantUML)

[plantuml, exti_sequence, svg]
----
@startuml
hide footbox

participant "GPIOC13"
participant "EXTI13"
participant "NVIC"
participant "ButtonExti::HandleClick"
participant "ModeManager"

"GPIOC13" -> "EXTI13" : Сигнал изменения уровня
"EXTI13" -> "NVIC" : Запрос EXTI15_10
"NVIC" -> "ButtonExti::HandleClick" : Вызов обработчика
"ButtonExti::HandleClick" -> "ModeManager" : SwitchModeManager()
@enduml
----

== Демонстрация результата

При запуске прошивки светодиоды начинают работать в одном из режимов. Каждое нажатие кнопки вызывает переключение режима на следующий. Переполнение таймера TIM5 вызывает обновление состояния текущего режима, создавая анимацию.

== Преимущества использования EXTI

* Мгновенная реакция на событие без задержек.
* Нет необходимости опрашивать вход в цикле.
* Освобождение процессора для других задач.
* Масштабируемость: можно добавить новые прерывания без изменений основной логики.

== Заключение

В данной работе реализована система обработки нажатия кнопки через внешний контроллер прерываний EXTI13 на STM32F411. Использование шаблонного программирования и модульной архитектуры позволило получить компактный, расширяемый и эффективный код. Предложенное решение демонстрирует подход к разработке событийно-ориентированных встраиваемых приложений и может быть масштабировано для работы с другими источниками событий и режимами.


== Приложение А: Исходные коды проекта

[source,cpp]
----
// Timer шаблон
template<typename TIMRegs, auto &modeManager>
class Timer {
public:
    static void OverloadHandler() {
        if (TIMRegs::SR::UIF::InterruptPending::IsSet()) {
            modeManager.UpdateModeManager();
            TIMRegs::SR::UIF::Set(0);
        }
    }
};
----

[source,cpp]
----
// ButtonExti шаблон
template<auto &modeManager>
class ButtonExti {
public:
    static void HandleClick() {
        if (EXTI::PR::PR13::Value1::IsSet()) {
            modeManager.SwitchModeManager();
            EXTI::PR::PR13::Value1::Set();
        }
    }
};
----

[source,cpp]
----
// Векторная таблица
extern "C" const tIntVectItem __vector_table[] = {
  ...
  ButtonExti<modeManager>::HandleClick,     // EXTI Line 15..10
  ...
  Timer<TIM5, modeManager>::OverloadHandler, // TIM5 global interrupt
  ...
};
----

[source,cpp]
----
// Инициализация и main
int __low_level_init(void) {
    RCC::CR::HSION::On::Set();
    RCC::CFGR::SW::Hsi::Set();
    RCC::APB2ENR::SYSCFGEN::Enable::Set();
    STK::CTRL::CLKSOURCE::CpuClock::Set();
    RCC::APB1ENR::TIM5EN::Enable::Set();
    RCC::AHB1ENR::GPIOAEN::Enable::Set();
    RCC::AHB1ENR::GPIOCEN::Enable::Set();

    GPIOA::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER5::Output::Set();
    GPIOC::MODER::MODER8::Output::Set();
    GPIOC::MODER::MODER9::Output::Set();
    GPIOC::MODER::MODER13::Input::Set();

    SYSCFG::EXTICR4::EXTI13::Value2::Set();
    EXTI::FTSR::TR13::Value1::Set();
    EXTI::RTSR::TR13::Value0::Set();
    EXTI::PR::PR13::Value1::Set();
    NVIC::ISER1::Write(1 << 8U);   // EXTI15_10
    NVIC::ISER1::Write(1 << 18U);  // TIM5

    const auto TimerDivider = SystemCoreClock / 1'000U;
    TIM5::PSC::Write(TimerDivider);
    TIM5::CR1::URS::Value1::Set();
    TIM5::ARR::Write(500U);
    TIM5::SR::UIF::Set(0);
    TIM5::CNT::Write(0);
    TIM5::DIER::UIE::Value1::Set();

    return 1;
}

int main() {
    EXTI::IMR::MR13::Value1::Set();
    TIM5::CR1::CEN::Enable::Set();
    modeManager.InitModeManager();
    for (;;) {}
    return 1;
}
----