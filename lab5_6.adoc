= Лабораторная работа 5,6
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица

include:: titulnik.adoc[]
== Добавление классов для программы


Добавление классов в программу на языке C++ является основой объектно-ориентированного подхода, позволяющего структурировать код, разделять ответственность между компонентами и упрощать его поддержку. Класс представляет собой шаблон, который определяет свойства (переменные-члены) и поведение (методы), доступные для объектов, созданных на его основе.

Для добавления класса в программу обычно создаются два файла: заголовочный файл (.h), который описывает интерфейс класса, и файл реализации (.cpp), содержащий определения методов. Такое разделение упрощает управление кодом, способствует повторному использованию и ускоряет процесс компиляции.

Заголовочный файл определяет структуру класса: перечисление переменных-членов, прототипы методов, а также объявление доступности (public, private, protected). Это позволяет другим частям программы знать, какие функции предоставляет класс, но скрывает детали их реализации.

Файл реализации включает определения методов, определённых в заголовочном файле. Здесь реализуется логика работы класса, что позволяет изменять её без воздействия на код, который использует класс. Включение заголовочного файла в файл реализации осуществляется через директиву *#include*.

Пример структуры заголовочного файла (`MyClass.h`):


[source,cpp]
----
#ifndef MYCLASS_H
#define MYCLASS_H

class MyClass {
private:
    int privateMember; 

public:
    MyClass(); // Конструктор
    ~MyClass(); // Деструктор

    void setMember(int value); // Метод установки значения
    int getMember() const; // Метод получения значения
};

#endif 
----


Пример структуры файла реализации (`MyClass.cpp`):

[source, cpp]
----
#include "MyClass.h"

MyClass::MyClass() : privateMember(0) {
    // Конструктор по умолчанию
}

MyClass::~MyClass() {
    // Деструктор
}


----

Этот подход обеспечивает инкапсуляцию, позволяя скрывать внутреннюю реализацию класса от остального кода. Методы класса предоставляют интерфейс для работы с его данными, что делает программу более модульной и удобной для расширения.



=== Класс ModeManager


В рамках реализации переключения светодиодов в разных режимах была разработана система управления, основанная на классе ModeManager. Архитектура проекта предусматривает использование абстрактного интерфейса IModeManager, класса реализации ModeManager, а также конфигурации режимов, представленной массивом указателей на объекты режимов (tMode).

Интерфейс IModeManager задает базовые методы для управления режимами, включая инициализацию, обновление и переключение. Такой подход обеспечивает модульность и гибкость системы, позволяя создавать различные реализации управления.

Класс ModeManager реализует функциональность, определенную в интерфейсе, и управляет массивом режимов, который передается в конструктор. Основными методами являются InitModeManager для инициализации текущего режима, UpdateModeManager для его обновления и SwitchModeManager для переключения на следующий режим.

Конфигурация массива режимов (tMode) представлена типом, основанным на std::array, что позволяет указывать указатели на объекты, реализующие интерфейс IMode. Такой подход делает добавление новых режимов простым и удобным, а также соответствует принципам объектно-ориентированного программирования, в частности принципу открытости/закрытости.

[plantuml]
----

Interface IModeManager {
    {abstract} void InitModeManager()
    {abstract} void UpdateModeManager()
    {abstract} void SwitchModeManager()
}

class ModeManager {
    tMode& modes
    std::uint8_t currentModeType
    + ModeManager(tMode& modes)
    + void InitModeManager()
    + void UpdateModeManager()
    + void SwitchModeManager()
}

Interface IMode {
    {abstract} void Init()
    {abstract} void Update()
}

class ModeConfig {
    tMode: std::array<IMode*, 3>
}

IModeManager <|-- ModeManager
IMode --> ModeConfig : use
IMode --o ModeManager: 0..n
ModeManager --> ModeConfig : use

----

Ниже представлена реализация каждого класса на основе диагараммы UML:

Код для объявления IModeManager:

[source, cpp]
----
#ifndef IMODEMANAGER_H
#define IMODEMANAGER_H

class IModeManager
{
public:
  virtual void InitModeManager() = 0; 
  virtual void UpdateModeManager() = 0; 
  virtual void SwitchModeManager() = 0;
};

#endif
----

Код для реализации ModeConfig:

[source, cpp]
----
#ifndef MODECONFIG_H
#define MODECONFIG_H

#include "ledconfig.h"
#include "IMode.h"

using tMode = std::array<IMode*, 3>;

#endif
----

Код для объявления ModeManager (тело класса):

[source, cpp]
----
#ifndef MODEMANAGER_H
#define MODEMANAGER_H

#include "IModeManager.h"
#include "ModeManagerConfig.h" // for tMode

class ModeManager : public IModeManager
{
public:
  ModeManager(tMode& modes); 
  void InitModeManager() override; 
  void UpdateModeManager() override; 
  void SwitchModeManager() override; 
private:
  tMode& modes; 
  std::uint8_t currentModeType; 
};

#endif
----

Код для реализации ModeManager (.cpp):

[source, cpp]
----
#include "ModeManager.h"

ModeManager::ModeManager(tMode& modeArr) : modes(modeArr), currentModeType(0) 
{
}

void ModeManager::InitModeManager() {
        modes[currentModeType]->Init();
}

void ModeManager::UpdateModeManager() {
        modes[currentModeType]->Update();
}

void ModeManager::SwitchModeManager() {
    currentModeType = (currentModeType + 1) % sizeof(modes); 
        modes[currentModeType]->Init();
}
----

Далее необходимо реализовать переключение режимов с помощью кнопки, для этого перейдем к созданию класс для кнопки.

=== Класс Button

Кнопка позволяет пользователю взаимодействовать с устройством, выполнять команды или управлять его функциями. Нажатие на кнопку инициирует конкретное действие или переключение режима работы.

Создадим классы `IButton` и `Button`.

В классе IButton определен метод isClick(), который должен быть реализован в наследуемых классах. Этот метод используется для проверки состояния кнопки на нажатие:

[source, cpp]
----
#ifndef IBUTTON_H
#define IBUTTON_H

class IButton {
public:
    virtual bool isClick() = 0;
};
#endif
----


Класс Button, наследующий от IButton, реализует метод isClick(). Этот метод проверяет состояние кнопки в определённом порту и возвращает true, если кнопка нажата (0 в состоянии порта):

[source, cpp]
----
#ifndef BUTTON_H
#define BUTTON_H
#include "IButton.h"

template<typename TPort, int pinNumber>
class Button : public IButton {
public:
      bool onClick() override
      {
         return (TPort::IDR::Get() & (1 << pinNumber)) == 0;
      }
      
private:
  bool currentStatus;
  std::uint32_t buttonPortStatus;
};
#endif
----

Шаблонные параметры TPort и punNumber используются для адаптации класса Button под конкретные порты и номера пинов. Метод Get() из TPort::IDR используется для получения состояния порта и проверки наличия сигнала на конкретном пине.


=== Итог работы с классами

Добавление классов в программу на языке C++ позволяет структурировать код, разделять ответственность между компонентами и упрощать поддержку. Заголовочные файлы описывают интерфейсы классов, а файлы реализации содержат определения методов. Класс ModeManager управляет режимами в системе, предоставляя интерфейс для инициализации, обновления и переключения между режимами. Конфигурация режимов осуществляется с использованием массива указателей на объекты, что обеспечивает гибкость и удобство добавления новых режимов.

Также был создан класс Button, который позволяет пользователю взаимодействовать с устройством. Класс проверяет состояние кнопки на нажатие и инициирует соответствующее действие. Это необходимо для управления функциями устройства через взаимодействие пользователя.

== Настройка тактирования платы

Тактирование платы в микроконтроллерах, таких как STM32F411RET6, касается установки частоты для различных блоков микроконтроллера, таких как ядро процессора, периферийные устройства и вспомогательные системы. Внутренний осциллятор высокой скорости (HSI) используется для генерации стабильной частоты, обычно 16, 24 или 32 МГц, без необходимости внешних компонентов. Этот осциллятор подходит для быстрого выполнения расчетов и обмена данными.

Внешний кварцевый генератор высокой скорости (HSE) используется для обеспечения высокоточной частоты, часто кварцевый резонатор на 8, 16 или 25 МГц. Этот источник тактирования обеспечивает высокую точность и стабильность частоты, что важно для задач, требующих высокой точности.

Фазовый автоподстройки частоты (PLL) используется для умножения частоты внешнего или внутреннего источника (HSI или HSE) до требуемой. Это позволяет настроить частоту системы в пределах возможностей микроконтроллера, обеспечивая гибкость при выполнении различных задач. Тактирование платы важно для стабильной работы всех компонентов микроконтроллера, включая процессор, память, периферийные устройства и взаимодействие с внешними устройствами. Настройка тактирования требует учета совместимости и эффективности использования ресурсов микроконтроллера.

=== Работа с HSI

HSI (High-Speed Internal) – это внутренний осциллятор высокой скорости, используемый в микроконтроллерах, таких как STM32F411RET6, для генерации стабильной частоты без необходимости внешних компонентов. Обычно частота HSI составляет 16, 24 или 32 МГц. Этот внутренний осциллятор подходит для быстрого выполнения расчетов и обмена данными в системе. Он используется для тактирования ядра процессора и других внутренних блоков микроконтроллера, обеспечивая базовую частоту работы системы.

[source, cpp]
----
std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" 
int __low_level_init(void)

  RCC::CR::HSION::On::Set();
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  RCC::CFGR::SW::Hsi::Set();
  while (!RCC::CFGR::SWS::Hsi::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

Описание кода:

Сначала включается внутренний кварцевый генератор с частотой 16 МГц, обеспечивая стабильный тактовый источник для системы. После этого код ожидает, пока генератор не станет готовым к использованию, проверяя флаг готовности.

Затем устанавливается SysTick, который используется для отслеживания времени в системе и создания таймерных интервалов. Для корректной работы SysTick необходим тактовый сигнал, соответствующий тактовому сигналу процессора.

Наконец, код включает тактирование системы конфигурации SYSCFG. Это необходимо для доступа к различным системным блокам, таким как GPIO, прерывания и другие настройки. Включение SYSCFG позволяет использовать расширенные возможности микроконтроллера.


=== Работа с HSE

HSE (High-Speed External) – это внешний кварцевый генератор высокой скорости, используемый в микроконтроллерах, таких как STM32F411RET6, для обеспечения высокоточной частоты. Часто это кварцевый резонатор с частотой 8, 16 или 25 МГц. HSE используется для предоставления стабильной и точной частоты для тактирования ядра процессора и других компонентов микроконтроллера, требующих высокой точности. Этот источник тактирования используется в тех случаях, когда требуется высокая стабильность и точность частоты для выполнения задач, таких как обработка данных, коммуникации и управление периферийными устройствами.

[source, cpp]
----
std::uint32_t SystemCoreClock = 8'000'000U;

extern "C" 
int __low_level_init(void)

  RCC::CR::HSEON::On::Set();
  while (RCC::CR::HSERDY::NotReady::IsSet())
  {

  }
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {

  }
  STK::CTRL::CLKSOURCE::CpuClock::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
----

=== Задание на PLL

PLL (Phase-Locked Loop) – это фазовый автоподстройки частоты, используемый в микроконтроллерах, таких как STM32F411RET6, для умножения частоты внешнего или внутреннего источника (HSI или HSE) до требуемой частоты системы. PLL позволяет изменять частоту на выходе, умножая или деля входную частоту, что делает его полезным для генерации высоких частот в системах, где недостаточно исходной частоты HSI или HSE.

С помощью PLL (<<PLL(set)>>) можно настроить частоту тактирования системы в пределах возможностей микроконтроллера, обеспечивая гибкость при выполнении различных задач. Это особенно важно для управления скоростью работы процессора и периферийных устройств, требующих различных уровней производительности и энергопотребления.

f = f(hse) × (PLLN / PLLM) /PLLP​

где: PLLM – делитель входной частоты; PLLN – множитель; PLLP – делитель на выходе PLL.

Для получения частоты 

f = 13.666МГц, например, выберем: PLLM = 10; PLLN = 137; PLLP = 8.

 Проверка f = 137 × 8 / 10 / 8 = 13.7 МГц.

.Регистр  PLL
[#PLL(set)]
image::PLL(set).png[]


[source, cpp]
----
std::uint32_t SystemCoreClock = 13'666'000U;

extern "C" 
int __low_level_init(void){
  
  RCC::CR::HSEON::On::Set();


  RCC::PLLCFGR::PLLSRC::HseSource::Set();

    //137
    RCC::PLLCFGR::PLLN0::Set(0b10001001);
   

    //8
    RCC::PLLCFGR::PLLP0::Set(0b11);
  

    //10
    RCC::PLLCFGR::PLLM0::Set(0b001011);
    

   
    RCC::CR::PLLON::On::Set();
    while (RCC::CR::PLLRDY::Unclocked::IsSet()) {
        
    }


    RCC::CFGR::SW::Pll::Set();
    while (!RCC::CFGR::SWS::Pll::IsSet()) {
      
    }

   
    RCC::APB2ENR::SYSCFGEN::Enable::Set();

    return 1;
}


----

=== Итоги

Настройка тактирования платы микроконтроллера STM32F411RET6 включает выбор источников частоты для различных блоков, таких как ядро процессора и периферийные устройства. Внутренний осциллятор высокой скорости (HSI) используется для генерации стабильной частоты, подходящей для быстрого выполнения расчетов и обмена данными внутри системы. Внешний кварцевый генератор высокой скорости (HSE) обеспечивает высокую точность и стабильность частоты, необходимую для задач, требующих высокой точности.

Фазовый автоподстройки частоты (PLL) умножает частоту внешнего или внутреннего источника (HSI или HSE) до требуемой, обеспечивая гибкость при выполнении различных задач. Настройка тактирования важна для стабильной работы всех компонентов микроконтроллера, включая процессор, память и периферийные устройства. Пример на C++ показывает, как включить внешние генераторы и настроить SysTick и SYSCFG для расширенных возможностей системы.

Работа с HSI и HSE обеспечивает стабильные и точные частоты для различных блоков микроконтроллера. Примеры кода демонстрируют настройку системы с использованием внешних 16 и 8 МГц генераторов. Задание на PLL позволяет умножить частоту для достижения нужной производительности и энергопотребления.