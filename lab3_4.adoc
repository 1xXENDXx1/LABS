= Лабораторная работа №3 и №4
:author: Чалов Иван Дмитриевич КЭ-413
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица

== Включение светодиодов елочкой без использования класса

На лекции было получено задание: реализовать включение диодов "елочкой" (последовательное включение и выключение светодиодов), спустя череду неудачных попыток был получен следующий код:

[source, cpp]
----
const std::uint32_t maskBit5 = (1U << 5U);
const std::uint32_t maskBit8 = (1U << 8U);
const std::uint32_t maskBit9 = (1U << 9U);

std::uint32_t* const prtGpiocOdr = reinterpret_cast<uint32_t*>(0x40020814U); // GPIOC
std::uint32_t* const prtGpioaOdr = reinterpret_cast<uint32_t*>(0x40020014U); // GPIOA

for(;;)
{

    *prtGpioaOdr |= maskBit5; 
    delay(1000000);
    *prtGpiocOdr |= maskBit9; 
    delay(1000000);
    *prtGpiocOdr |= maskBit8; 
    delay(1000000);
    *prtGpiocOdr |= maskBit5; 
    delay(1000000);

 
    *prtGpioaOdr &= ~maskBit5; 
    delay(1000000);
    *prtGpiocOdr &= ~maskBit9; 
    delay(1000000);
    *prtGpiocOdr &= ~maskBit8; 
    delay(1000000);
    *prtGpiocOdr &= ~maskBit5; 
    delay(1000000);

}

----

Таким образом, код управляет светодиодами, подключёнными к микроконтроллеру, используя порты GPIOA и GPIOC. Сначала определяются битовые маски, которые задают конкретные биты (5, 8 и 9) в 32-битных числах, представляющие определённые выводы микроконтроллера, подключённые к светодиодам. Каждая маска, по сути, сдвигает единичный бит в нужную позицию, создавая уникальные значения для включения конкретного светодиода.

Далее, создаются указатели на регистры GPIOA и GPIOC, которые указывают на конкретные адреса в памяти, привязанные к этим портам. Эти указатели позволяют программе управлять состоянием светодиодов, записывая значения непосредственно в регистры портов. Через побитовые операции с этими регистрами можно включать и выключать светодиоды, не затрагивая другие биты и выводы, которые могут быть подключены к другим компонентам.

В основном цикле, который выполняется бесконечно, светодиоды включаются и выключаются последовательно. Для этого в регистры GPIOA и GPIOC записываются значения с использованием операции побитового ИЛИ, что позволяет задать нужный бит в регистре, сохраняя остальные биты. После каждой операции включения или выключения светодиода вызывается функция задержки delay, которая создаёт паузу, необходимую для того, чтобы визуально наблюдать, как светодиоды загораются и гаснут.

Наконец, светодиоды выключаются с помощью побитовой операции И с отрицанием соответствующей маски. Эта операция сбрасывает заданные биты, что приводит к отключению светодиодов.

Однако, такой код имеет огромный ряд недостатков, одним из которых является реализация подобного кода на 10000 светодиодов. После чего было принято решение переделать код так, чтобы, практически не меняя код, можно было полностью поменять вид включения диодов и колличество включение диодов.

== Включение светодиодов елочкой с использованием класса

Далее был придуман код с использованием класса. Класс – это пользовательский тип данных, который объединяет данные и методы, работающие с этими данными, в одну логическую единицу. Классы помогают структурировать и организовывать код, делая его более понятным и удобным для использования. Они являются фундаментом объектно-ориентированного программирования (ООП) и позволяют создавать объекты – экземпляры классов, которые имеют своё состояние (данные) и поведение (методы). Ниже представлен класс для включения, выключения и по переменного включения и выключения диодов:

[source, cpp]
----
class ILed
{
    virtual void Light() = 0;
    virtual void Off() = 0;
    virtual void Switch() = 0;
};
----
ILed представляет собой интерфейсный класс в C++, который определяет общий набор методов для управления светодиодами, таких как Light(), Off() и Switch(). Этот класс создан с использованием чисто виртуальных функций (все методы объявлены как virtual и инициализированы значением = 0), что делает его абстрактным. Это значит, что объект класса ILed нельзя создать напрямую; вместо этого класс служит основой для наследования.

Каждый метод выполняет конкретную задачу: Light() предназначен для включения светодиода, Off() – для его выключения, а Switch() – для изменения текущего состояния (включение при выключенном состоянии и наоборот).

Далее создается класс Led:

[source, cpp]
----

class Led : public ILed
{
public:
    Led(std::uint32_t registerAddres, std::uint32_t pinNumber) :
    registerAddr(registerAddres), pinNum(pinNumber) // Конструктор
    {
    }

    void Light() override // Функция включения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) |= (1 << pinNum);
    }
    void Off() override // Функция выключения светодиода
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) &= ~(1 << pinNum);
    }
    void Switch() override // Функция изменения состояния светодиода на противоположное
    {
        *reinterpret_cast<std::uint32_t*>(registerAddr) ^= (1 << pinNum);
    }
private:
    std::uint32_t registerAddr; // Адрес указываемого регистра (порта)
    std::uint32_t pinNum; // Номер указываемого номера бита
};
----

Класс Led реализует интерфейс ILed и предоставляет методы для управления светодиодом. В конструкторе класса задаются адрес регистра и номер пина, которые определяют, к какому порту и выводу микроконтроллера будет подключён светодиод. Метод Light() включает светодиод, устанавливая соответствующий бит в регистре, метод Off() выключает светодиод, сбрасывая этот бит, а метод Switch() переключает состояние светодиода, изменяя бит с помощью операции XOR. Все методы используют побитовые операции для работы с регистрами, указанные через указатель на адрес в памяти.

== Реализация другого принципа включения светодиодов

Следующее лекционное задание: настроить включение диодов по выбору пользователя, а именно реализовать включение диодов в шахматном порядке, включение елочкой и включение всех светодидов, причем весь код должен быть описан отдельной функцией в классе своего типа включения.

*Разберем включение светодиодов елочкой:*

[source, cpp]
----
class TreeMode:public IMode
 {
 public:
    TreeMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
  void Update() override
  {  
    leds[currentLedIndex]->Switch();
    currentLedIndex++;
    if(currentLedIndex >= leds.size())
    {
      currentLedIndex=0;
    }
  }  
    
  void Init() override
  { 
    currentLedIndex=0;
    for(auto it: leds)
     {   
          it->Light();
     }   
 
   }   
    private:
      tLeds& leds;
      std::size_t currentLedIndex;
    };

      for(;;)
    
int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;


  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};

    TreeMode treemode(leds);
    treemode.Init();

  for(;;)
  {

   treemode.Update();
  
  }

}
----

Конструктор класса TreeMode принимает ссылку на массив светодиодов, который сохраняется для дальнейшего использования в объекте. Это позволяет работать с переданными светодиодами в рамках этого класса.



*Реализация шахматного включения светодиодов:*

[source, cpp]
----
class ChessMode: public IMode
    {
    public:
      ChessMode(tLeds& ledsArr): leds(ledsArr)
      {
      }
      void Update() override
      {
        for(auto it: leds)
        {
          it->Switch();
          
        }
      }
      
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();

        }
        for(auto i=0; i< leds.size(); ++i)
        {
          if ((i%2)==0)
          {
            leds[i]->Switch();
          }
        }
      }
    private:
      tLeds& leds;
    };

int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;


  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};

    ChessMode chessmode(leds);
   
    chessmode.Init();

  for(;;)
  {

   chessmode.Update();
   delay(1000000); 
  
  }

}
----
В представленном коде реализован класс ChessMode, который управляет светодиодами с использованием шахматного паттерна. В классе определены два основных метода: Init и Update.

Конструктор класса принимает ссылку на коллекцию светодиодов и сохраняет ее для дальнейшего использования в объекте. В методе Init все светодиоды сначала включаются с помощью вызова метода Light(). Затем, для создания шахматного паттерна, осуществляется проверка индекса каждого светодиода. Для четных индексов светодиодов вызывается метод Switch(), что приводит к их переключению (включению или выключению в зависимости от текущего состояния).

Метод Update переключает состояние всех светодиодов, вызывая метод Switch() для каждого из них, что изменяет их состояние с включенного на выключенное и наоборот.

В функции main происходит настройка портов и пинов для работы с GPIO. Светодиоды, такие как led1, led2, led3 и led4, создаются как объекты и передаются в массив leds, который затем используется в объекте ChessMode. Сначала вызывается метод Init для инициализации светодиодов, а затем метод Update для последовательного переключения их состояний. Задержка между обновлениями задается через функцию delay(1000000).

Таким образом, класс ChessMode управляет светодиодами, создавая шахматный паттерн и позволяя переключать их состояния через обновления, реализуя динамическое управление светодиодами на микроконтроллере.


*Включение всех диодов:*

[source, cpp]
----
class AllMode:public IMode
 {
 public:
    AllMode(tLeds& ledsArr): leds(ledsArr)
    {
        
    }
       void Update() override
    {
       
        static bool toggle = true;

        for (auto& led : leds)
        {
            led->Switch(); 
        }

        
        toggle = !toggle;
    }
      
      void Init() override
      {
        for(auto it: leds)
        {
          it->Light();

        }

      }
private:
 tLeds& leds;
 };

 int main()
{  
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;


  
  Led<GPIOC, 5> led1;
  Led<GPIOC, 8> led2;
  Led<GPIOC, 9> led3;
  Led<GPIOA, 5> led4;

  
   tLeds leds = {
    &led1,
    &led2,
    &led3,
    &led4};

    AllMode allmode(leds);
    
    allmode.Init();

  for(;;)
  {

   allmode.Update();
   delay(1000000); 
  
  }

}
----


В данном коде реализован класс AllMode, который управляет светодиодами в режиме, при котором все светодиоды включаются одновременно. Класс содержит два метода: Init и Update.

Метод Init инициализирует светодиоды, включая их с помощью метода Light() для каждого элемента массива светодиодов. Этот метод вызывается один раз при старте работы программы.

Метод Update включает все светодиоды, вызывая метод Light() для каждого из них. Этот метод может быть вызван многократно в цикле, что приводит к повторному включению светодиодов, хотя, так как они уже включены в методе Init, это действие не изменяет их состояние.

В функции main происходит настройка тактирования для портов GPIOA и GPIOC, а также настройка пинов для управления светодиодами. Затем создаются объекты светодиодов, которые привязываются к соответствующим пинам. Эти объекты добавляются в массив, передаваемый в конструктор объекта AllMode. После этого вызывается метод Init, который включает все светодиоды. В бесконечном цикле вызывается метод Update, который снова включает светодиоды, хотя они уже включены. В программе также присутствует задержка, реализованная через вызов функции delay(1000000).

Этот код позволяет управлять светодиодами на портах GPIOA и GPIOC, при этом светодиоды всегда остаются включенными после вызова Init, и метод Update не изменяет их состояния.
